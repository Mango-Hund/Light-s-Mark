## 拓扑排序
### 基本概念
简单来说，就是将图中的所有节点展开成一维序列，对于序列中任意的节点`(u,v)`，如果在序列中`u`在`v`的前面，则说明在图中存在从`u`出发达到`v`的通路，即`u`排在`v`的前面。反之亦然。
同时，需要知晓【入度】和【出度】的概念：
* 入度：有多少条边直接指向该节点；
* 出度：由该节点指出的边有多少条；

因此，对于有向图的拓扑排序，我们可以使用如下思路输出拓扑排序(BFS)：
1. 起始时，将所有入度为0的节点进行入队（入度为0，说明没有边指向这些节点，将它们放到拓扑排序的首部，不会违反拓扑序规定）；
2. **从队列中进行节点出队操作，出队序列就是对应我们输出的拓扑序。**  对于当前弹出的节点`x`，遍历`x`的所有出度，即遍历所有由`x`直接指向的节点`y`，对`y`做入度减一的操作（因为`x`已经从队列中弹出，被添加到拓扑序中，等价于从`x`节点在有向图中被移除，相应的由`x`发出的边也应当被删除，带来的影响是与`x`相连的节点y的入度减一）；
3. 对`y`进行入度减一之后，检查`y`的入度是否为0，如果为0则将`y`入队（当`y`的入度为0，说明有向图中在y前面的所有节点均被添加到拓扑序中，此时`y`可以作为拓扑序中的某个片段的首部被添加，而不是违反拓扑序的定义）
4. 循环流程2、3直到队列为空。

![](../../../assets/Pasted%20image%2020220531170114.png)

上述 `BFS` 方法能够求得「某个有向无环图的拓扑序」的前提是：**我们必然能够找到（至少）一个「入度为 0的点」，在起始时将其入队。**

这可以使用反证法进行证明：假设有向无环图的拓扑序不存在入度为 0的点。

**那么从图中的任意节点`x`进行出发，沿着边进行反向检索，由于不存在入度为0的节点，因此每个点都能够找到上一个节点。**

**当我们找到一条长度为`n+1`的反向路径时，由于我们图中只有 `n`个节点，因此必然有至少一个节点在该路径中重复出现，即该反向路径中存在环，与我们「有向无环图」的起始条件冲突。**

得证「有向无环图的拓扑序」必然存在（至少）一个「入度为0的点」。


