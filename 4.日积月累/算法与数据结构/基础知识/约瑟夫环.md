## 约瑟夫环
### 问题描述
`0,1,...,n-1`这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈中删除第m个数字。求出这个圆圈里剩下的最后一个数字。

例如，`0,1,2,3,4`这 5 个数字组成一个圆圈，从数字 0 开始每次删除第 3 个数字，则删除的前 4 个数字依次是 `2,0,4,1`，因此最后剩下的数字是 `3`。如下图所示
![](../../../assets/Pasted%20image%2020220504105502.png)
### 解法
解决约瑟夫环问题，采用倒推，推导结论即最后剩下的这个数字，在最开始数组中的位置。
1. 剩下最后一个数字（简称“它”）的时候，总个数为1，位置为$pos=0$；
2. 那么它在上一轮是安全的，总个数为2，它的位置$pos=(0+m)\%2$；
3. 那么它在上上轮也是安全的，总个数为3，它的位置$pos=((0+m)\%2+m)\%3$；
4. 那么它在上上上轮也是安全的，总个数为4，它的位置$pos=(((0+m)\%2+m)\%3+m)\%4$；
5. ...
6. 那么它在游戏开始的第一轮也是安全的，总个数为n，它的位置pos就是最后的结果

即如果从下向上反推：假设前一轮索引为pos，那么当前轮次的位置就是`(pos+m)%当前伦茨的人数`。

最后由于给出的数字是`nums=0,1,2,...,n-1`，即`nums[i]=i`，因此找出pos就相当于找到了这个数字。

### 数学推导
**定义**
约瑟夫环操作：把一些数字排成一个圆圈，从数字 0 开始，每次从这个圆圈里删除第 m个数字，直到最后只剩一个数字。
函数$f(n,m)$：表示对 n个数字`0,1,2,...,n-1`做约瑟夫环操作，最后剩下的这个数字。

**整体思路**
在`0,1,2,...,n-1`这n个数字中，第一个被删除的数字是$(m-1)\%n$。为了简单起见，把$(m-1)\%n$记为k，那么删除$k$之后剩下的`n-1`个数字为`0,1,...,k-1,k+1,...,n-1`，并且下一次删除时要从`k+1`开始计数。相当于在剩下的序列中，`k+1`排在最前面，所以第二次的操作序列是`k+1,...,n-1,0,1,...,k-1`

在这个新序列上再完成约瑟夫环操作，最后剩下的数字应该是关于$n$和$m$的函数，可以用$f(n,m)$进行表示。但由于现在的这个序列的排列（从`k+1`开始）和最初的序列（从0开始）
不一样，因此这个时候的函数已经不同于最初的函数，记为$h(n-1,m)$。

由于在最初序列上和新序列上完成的约瑟夫操作剩下的数字均为同一个，所以有$f(n,m)=h(n-1,m)$。

下面的工作就是求解新函数$h(n-1,m)$，使其能够用`f(n-1,m)`表示出来。

由于`f(n-1,m)`是定义在以0为开始的序列上的，所以我们把剩下的这`n-1`个数字的序列进行映射，映射到结果是形成一个`0,...,n-2`的序列。
```txt
 k+1->0
 k+2->1
 ...
 n-1->n-k-2
 0->n-k-1
 1->n-k
 ...
 k-1->n-2
```

该映射函数是一个一元一次函数，定义为$p(x)$，则$p(x)=(x+n-k-1)\%n$
其中$p(x)$函数是由分段函数归纳的 
$$p(x)=\begin{cases} x+n-k-1 & 0\leq x \leq k-1 \\ x-k-1 & k+1\leq x\leq n-1\end{cases}$$
从左到右的映射是$p(x)$，从右到左的映射是逆映射$p^{-1}(x)=(x+k+1)\%n$，逆函数求解即把x替换为$p(x)$，将$p(x)$替换为x。

由于映射之后的序列和最初的序列有相同的形式，因此在映射之后的序列上的函数可以表示为$f(n-1,m)$，即$f(n-1,m)=p(h(n-1,m))$。

所以有
$$h(n-1,m)=p^{-1}(x)(f(n-1,m))=[f(n-1,m)+k+1]\%n$$
将$k=(m-1)\%n$代入可得
$$f(n,m)=h(n-1,m)=[f(n-1,m)+m]\%n$$

当$n=1$时，序列中只有一个数字，总结上述推导，得到最终结果为
$$f(x)=\begin{cases}0&n=1 \\ [f(n-1,m)+m]\%n&n>1\end{cases}$$
### 代码
```java
class Solution{
    public int lastRemaining(int[] nums, int m)
        int p = 0;
        for(int i=2; i<=n; i++){
            p = (p+m) % i;
        }
        return p+1;
}
```